Substantial prior work exists regarding implementations of the Actor Model for creating distributed systems. Major libraries and frameworks such as Akka (Java) and Orleans (C#) provide Actor Model support across multiple languages. However, the most prominent and successful implementation is the Elixir programming language.

In the 1980s, Swedish telecommunications company Ericsson experimented with functional programming languages to address telecommunications challenges, ultimately developing Erlang. Erlang focused on concurrency, distribution, and fault tolerance by implementing the Actor Model at the language level. BEAM, the abstract machine that served as the runtime for Erlang programs, represented Ericsson's greatest achievement in this domain. (At the time, the term "virtual machine" was not yet applied to such systems.) However, Erlang's syntax was considered complex, creating a barrier to broader adoption.

In the early 2010s, José Valim was developing solutions for distributed systems, the same challenges Ericsson had addressed three decades earlier. Upon discovering Erlang and BEAM, he recognized their effectiveness but found them difficult to use. This led to the creation of Elixir, which combined BEAM's power and the Actor Model's flexibility with a more accessible syntax inspired by Ruby.

Unlike library-based implementations that add Actor Model support to existing languages, Elixir makes the Actor Model the default development paradigm. It achieves this through native support for green threads, fault tolerance, and remote inter-process communication—differentiators that established Elixir as the leading Actor Model platform.

This dynamic language continues gaining recognition, ranking as the second most admired programming language for three consecutive years in Stack Overflow's Developer Survey. Therefore, this work will use Elixir as the reference implementation and state-of-the-art example of the Actor Model.

## The Elixir Programming Language

Elixir's design philosophy fundamentally differs from object-oriented languages. Instead of classes instantiated into objects, Elixir uses modules that are spawned as actors by design. This approach makes the Actor Model not just a pattern but the core paradigm of the language.

The actors in Elixir are represented by Erlang processes (hereafter referred to simply as processes). These lightweight processes are created using the `spawn` function, which takes three parameters: a module, a function name from that module, and a list of arguments. When called, spawn executes the specified function in a new process and returns a Process Identifier (PID) that serves as the actor's address.

Communication between actors happens through message passing using two primary functions: send for dispatching messages to a process via its PID, and receive for handling incoming messages within a process. This message-passing mechanism forms the foundation of Elixir's concurrent and distributed capabilities.

Since Elixir builds extensively on Erlang's ecosystem and runs on the BEAM virtual machine, references to both Erlang and BEAM will appear frequently throughout this discussion of Elixir's features and capabilities.

### The Actor Model in Elixir

Elixir's implementation of the Actor Model is remarkably straightforward, requiring minimal effort to create concurrent and distributed actor systems. The language's design makes actor-based programming the natural approach rather than an additional pattern to learn.

**Messages** in Elixir are represented by any valid Elixir data structure: atoms, strings, numbers, tuples, lists, or even complex nested structures. This flexibility allows developers to design message protocols that best fit their application's needs without being constrained by rigid message formats.

**Addresses** are Erlang Process Identifiers (PIDs), which are unique identifiers automatically generated by the BEAM virtual machine when a process is spawned. These PIDs serve as the actor's address, enabling message routing in both local and distributed environments.

**Message handling** occurs through the `receive` construct, which allows a process to wait for and pattern-match incoming messages. This mechanism enables actors to process different types of messages with appropriate handling logic, making the system both robust and expressive.

### Elixir Basics

Elixir is a dynamically typed programming language, it means that types are checked only at runtime. Newer versions of the language are experimenting with optional type annotations but still early stages.

There are many different native data types in Elixir:

```rb
i = 123 
f = 3.14 
s = "héllo" # UTF-8 
c = 'hello' # Charlists (list of ints)
b = true
a = :atom
```

The special syntax `:somename` is used to declare atoms, an Erlang concept. They are constants named by themselves and used in many scenarios. They are used to represent status codes, function names, tags or even represent primitive data values:

```rb
true == :true
false == :false
nil == :nil
```

When it comes to compound data, elixir has 2 main types: tuples and lists. The former are fixed size and quickly indexable. The later are single linked lists with dynamic length. Tuples are heavly used as simple structured data objects. Data as a whole in Elixir is immutable, it means that you cannot change data, but only used it to produce new data.

```rb
response = {:ok, "Some message"}
status = elem(response, 0) # :ok
response = put_elem(response, 1, "Another message") # {:ok, "Another message"}

data = [1, 2, 3, 4]
data = ["0" | data] # ["0", 1, 2, 3, 4]
data = data ++ [5] # ["0", 1, 2, 3, 4, 5]
```

The `=` is called the bind operator, because it does not simply do attribution, but can be used for pattern matching.

```rb
x = 1
1 = x # That succeeds
2 = x # That will crash

{status, message} = {:fail, "the system panicked"}

IO.puts "It's a #{status}. Because #{message}"
# It's a fail. Because the system panicked
```

More broadly, pattern matching can be done with the `->` syntax:

```rb
response = {:ok, "Content"}

case response do
	{:ok, content} -> IO.puts "Success with content: #{content}"
	{:err, cause} -> IO.puts "Ugh, it failed due to: #{cause}"
end
```

In Elixir, there are some different forms of declaring functions, and they can be namespaced with the usage of modules:

```rb
defmodule Math do
  # Public function
  def add(a, b) do
    a + b
  end

  # Shorthand single-line
  def mul(a, b), do: a * b

  # Private function (only callable inside module)
  defp square(x), do: x * x

  # Multiple function heads with pattern matching
  def abs(n) when is_number(n) and n < 0, do: -n
  def abs(n) when is_number(n), do: n
end

IO.puts(Math.add(2, 3))   # 5
IO.puts(Math.mul(4, 5))   # 20
```

### Example

Now that you are introduced to some elixir syntax, look at a simple example of how to implement a system using actors in Elixir:

```rb
defmodule Echo do
    def init do
        # Waits for a message
        receive do
            # Gets the sender and message content
            {sender, msg} -> 
                # Echoes the response with success (`:ok`)
                send(sender, {:ok, "Echoing: #{msg}"})
                # Loop
                init()
        end
    end
end

defmodule Example do
    def main do
        # Starts the actor
        addr = spawn(Echo, :init, []) 
        # Sends a message
        send(addr, {self(), "Hello world"}) 
        
        # Waits for the response
        receive do 
            {:ok, response} -> 
                # Displays the response
                IO.puts(response) 
        end
    end
end
```

In the example above, it's defined a simple echo actor. It receives a message that must contain the address of the sender and some message. It then sends back to the sender a message with content `:ok` and the received message prefixed with `Echoing: `. Finally, there's a recursive call to `init` so the actor can handle more messages since Elixir has no loops.

In the `Example` module, the call to `spawn` will start the actor through the `init` function of the `Echo` module without any parameters. This function will return the PID of the created process that serves as the actor's address. The `send` function sends to the newly created actor a tuple where the first element is the PID of the current process and the second is the string `"Hello world"`.

At this moment, the call to `receive` in the `init` function comes into action. It will receive the message and return to the sender a new tuple where the first element is `:ok` and the second is the string `"Echoing: Hello world"`. Because of the recursive call this actor is ready to receive more messages.

The call to `receive` in the `main` function will now handle the actor's response. It patiently waited for a response and can now verify that the response indeed contains an `:ok` and display the string `Echoing: Hello world` in the terminal.

## References
- https://erlang.org/course/history.html
- https://www.erlang.org/faq/academic
- Programming Elixir 1.6
- https://survey.stackoverflow.co/