All systems are developed with a purpose. The way to know if the system is attending to its purpose is by setting requirements that impose restrictions and point the development process to the right direction. Requirements themselves are a huge research area, but they can be mainly splitted into 2 groups: functional and non-functional.

Functional requirements are restrictions that specify what the system should be capable of. A functional requirement for a social media can be the capability to post pictures. On the other hand, non-functional requirements are restrictions that define how something should be done. A non-functional requirement for the forementioned social media can be the safe storage of the users' pictures preventing unauthorized access to it. For short, functional requirements define features, while non-functional ones set quality expectations.

[[Software Architecture in Practice Challenges and Opportunities]] defines software architecture as a collection of design decisions that affect the structure, behavior, and overall quality of a software system, serving as the foundation for subsequent decisions. It's the research field that bright light to non-functional requirements. Throughout the years, many of those quality design decisions were packed together into what are called architectural patterns or simply patterns. 

So patterns can be defined as reusable concepts that can be applied to solve similar issues for systems in similar contexts, regarding non-functional needs. It means that a pattern can be applied to any system, no matter its features, as long as they have similar quality requirements. 

[[Software Architectural Patterns in Practice An Empirical Study]] states that if features where the only important part, there would be no need to have software architecture at all. But at the same time, they notice that this is not what happens in reality. Quality requirements happen to be not as relevant as they should when choosing architectural patterns for a system in the industry, and this brings long-term consequences for reliability, maintenability, testabilty, among other complications.

The purpose of this work is to experiment with a particular architectural pattern called the Actor Model. The idea is to use this pattern in a project that is way off the quality requirements that it attends to and understand what are the consequences.